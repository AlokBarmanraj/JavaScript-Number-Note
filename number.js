//----------JavaScript Number----------//


const x = 5;       // x Nuumber//
const y = 5.5;

const num = 999999999999999;       //JavaScript Number System 64bit 15 ডিজিটে সবথেকে বড় সংখ্যা (9) নিলে  এবং 15 বেশি সংখ্যা নিলে সেটা কাজ করে না//
console.log(num);

//Example//
const numb = 9999999999999999;      //15 বেশি সংখ্যা নিলে সেটার মান পরিবর্তন হচ্ছে// কিন্তু দশমিকের পর 17 ঘর নিলে মোটামুটি একি রেজাল্ট পাওয়া যাবে, কিন্তু এর পর গেলে অন্য রকম রেজাল্ট আসতে পারে //
console.log(numb);

const num1 = 3333333333333333;     // অন্য কোন সংখ্যা নিলে এবং ১৫ বেশি নিলে কোন পরিবর্তন হচ্ছে না //কিন্তু 15 ডিজিটে সবথেকে বড় সংখ্যা {9} নিলে পরিবর্তন হচ্ছে//
console.log(num1);


const num2 = 0.4;
const num3 = 0.5;
console.log(num2+num3);         //এখানে  console মান সঠিক দিয়েছে //

const num4 = 0.6;
const num5 = 0.7;
console.log(num4+num5);      //কিন্তু এখানে console মান সঠিক  দিচ্ছে না, এর কারণ  যখন  আমরা {0.6+0.7} ধরণের মান দিয়ে থাকি তখন সেটা চলমান থাকে, যখন সে দেখে চলমান রয়েছে তখন সেটা পুনপুনিক না দেখিয়ে {1.2999999999999998} মান দেখায় //

//Example// 16 bit
/*
1.3
    1    .    0.5    0.25    0.125    0.0625    0.03125    0.015625    0.0078125
    1    .     0       1       0         0         1           1           0

Decimal---Binary
0.3*2    =0.6
0.6*2    =0.2     //এখানে মান হচ্ছে 1.2 কিন্ত নিব 0.2 কারণ 1 যাবে 0.25//
0.2*2    =0.4
0.4*2    =0.8
0.8*2    =0.6    //এখানে মান হচ্ছে 1.6 কিন্ত নিব 0.6 কারণ 1 যাবে 0.03125//
0.6*2    =0.2    //এখানে মান হচ্ছে 1.2 কিন্ত নিব 0.6 কারণ 1 যাবে 0.015625//
0.2*2    =0.4
0.4*2    =0.8    //একই মান বার বার রিপিট হচ্চে //এবং পর্যায় ক্রমে চলতে থাকিচ্ছে  এই কারণে মান [1.2999999999999998] পরিবর্তন হচ্ছে// 
*/


const num6 = 0.6;
const num7 = 0.7;
console.log((num6 * 10 + num7 * 10) / 10);     //যদি আমরা এই ভাবে করি তাহলে সঠিক মান পাব//

const num8 = 0.6;
const num9 = 0.7;
const result = num8 +num9;
console.log(result.toFixed(2));    //আমরা এই ভাবেও  করতে পারি, তবে এটা Strong হয়ে যাবে এবং নাম্বারে পরিবর্তন করতে হবে //

const num10 = 0.6;
const num11 = 0.7;
const results = (num10 + num11).toFixed(2);
console.log(new Number(results));   //নাম্বারে পরিবর্তন সিষ্টেম, নাম্বারে পরিবর্তন করার সময় [new Number] ব্যবহার Recommend না । [new Number] এটি তখনি ব্যাবহার করবেন যখন জরুরি ভাবে [new Number] ব্যবহার করতেই হবে।

const str = 0.6;
const str1 = 0.7;
const str2 = (str + str1).toFixed(2);
console.log(str2);

const a = 10;
const b = 20;
const c = 30;
console.log(a + b + c);

console.log(a + b + c + str2);      //JavaScript Left to Right কাজ করে েএই কারণে মান 601.30 এসেছে//কারণ a + b + c মান 60 ঠিক দিয়েছে কিন্তু str2 মান 1.30 শুধু বসিয়ে দিয়েছে  যার কারণে মান 601.30 হয়েছে  কিন্তু  আমরা str2 মান কে (console.log(new Number(str2)) নাম্বারে কনভাট করে যোগ করতে পারি ।

console.log(a + b + str2 +c);     //আবার আমাদের মান ছিল 601.30 কিন্তু হয়ছে 301.3030 এর কারণ a + b যোগ করে মান পেয়েছি 30 এখানে str2 মান 1.30 এবং c মান 30, ফলে a + b মান 30 ঠিক দিয়েছে কিন্তু str2 মান 1.30 শুধু বসিয়ে দিয়েছে কারণ str2 হচ্ছে String যাকে সে যোগ করবে না এবং এখানে a + b + str2 +c এর মধ্যে str2 c এর সামনে থাকার কারণে c এর মান শুধু বসিয়ে দিয়েছে যার ফলে মান 301.3030 হয়েছে ।

console.log(str2 + a + b + c);     //এখানেও  একই ভাবে কাজ করেছে str2 মান 1.30 শুধু বসিয়ে দিয়েছে কারণ str2 হচ্ছে String যাকে সে যোগ করবে না এবং a মান 10  b মান 20 c মান 30 এর মান পর্যায় ক্রমে বসিয়ে দিয়েছে ফলে মান 1.30102030 হয়েছে।

console.log(c - str2);    //এখানে আবার str2 মান কে নাম্বারে কনভাট করার চেষ্টা করেছে এবং নাম্বারে কনভাট করতে পেরেছে, যার ফলে c এর মান 30 সাথে বিয়োগ করতে সফল হয়েছে । শুধু বিয়োগ(-) না str2 গুণ(*) ভাগ(/) সব ক্ষেত্রে সে নাম্বারে কনভাট করতে পারবে এবং সঠিক মান বের করে দিতে পারবে //
//Example//
console.log(a * str2);
console.log(b / str2);

const d = 30;
const e = 'JavaScript';
const f = d-e;
console.log(f);        // আমরা বলেছিলাম যোগ(+) ক্ষেত্রে ছাড়া  বিয়োগ(-), গুণ(*), ভাগের(/) ক্ষেত্রে মান String থাকলে সেটাকে সে নাম্বারে কনভাট করে কিন্তু এখানে e এর const e = 'JavaScript' মানে কোন নাম্বার নেই যার কারণে সে নাম্বরে কনভাট করতে পারছে না ফলে মান NaN দেখাছে যদি e এর মান 'JavaScript' না থেকে কোন সংখ্যা (125) থাকতো তাহলে সঠিক মান বের হতো //

console.log(typeof(f));      //কিন্তু f এর typeof number দেখাছে //

//While loop Infinite //
let numbr = 3;
let value = "";

while (numbr <= 500) {            //এখানে আমরা যদি <= 100 দিই তাহলে  মান 100 থেকে বেশি হয়ে থেমে যাচ্ছে //
    numbr= numbr*numbr;
    value = value + numbr + '<br>';
}
document.getElementById('bar').innerHTML = value;

let numbr1 = 3;
let value1 = "";

while (numbr1 != Infinity) {             //এখানে দেখেন != Infinity দেওয়ার কারণে মান বাড়তে বাড়তে ইটুডি পাওয়ারে(e+) চলে গেছে পরে বলে দিচ্ছে (Infinity) যার মানে হচ্ছে আর হিসাব করবো না // এটা হচ্ছে পজেটিভ Infinity //

    numbr1= numbr1*numbr1;
    value1 = value1 + numbr1 + '<br>';
}
document.getElementById('bar').innerHTML = value1;



//Binary Convert//
const duo = 30;
console.log(duo.toString(2));   // duo এখানে ছিল নাম্বার কিন্তু toString ব্যবহারের জন্য হয়ে গেছে String  কিন্ত আমরা duo=30 বাইনারি মান দেখতে চাই, কিন্তু আমরা জানি বাইনারি বেস 2 । যার কারণে (2) দিতে হয়েছে //

//Computer যে নাম্বার টা বোঝে সেটা বাইনারি, আর বাইনারি বেজ=2। এর মানে হচ্ছে Computer 0, 1 ছাড়া কোন সংখ্যা বোঝে না  Example:{(30=11110)ব্রেকেটের নিচে 2 থাকবে}//

//ডেসিমেল বেজ= 10(0,1,2,3,4,5,6,7,8,9)    Example:{(30)ব্রেকেটের নিচে 10 থাকবে}//

//অকটাল বেজ= 8 (0,1,2,3,4,5,6,7)         Example:{(30)ব্রেকেটের নিচে 8 থাকবে}//

//হেকজা-ডেসিমেল বেজ= 16 (ডেসিমেল বেজ=0,1,2,3,4,5,6,7,8,9 এবং হেকজা বেজ=A,B,C,D,E,F যেখানে A=10, B=11, C=12, D=13, E=14, এবং F=15 ব্যবহার করা হয়)      Example:{(BDF7)ব্রেকেটের নিচে 16 থাকবে}
 
//Example//
//{(248)ব্রেকেটের নিচে 10 } কে ডেসিমেল থেকে বাইনারি কনভাট -=//
const duo1 = 248;
console.log(duo1.toString(2)); 
/*
ডেসিমেল -- বাইনারি
248 / 2 = 124     ভাগশেষ =0
124 / 2 = 62      ভাগশেষ =0
62  / 2 = 31      ভাগশেষ =0
31  / 2 = 15      ভাগশেষ =1
15  / 2 = 7       ভাগশেষ =1
7   / 2 = 3       ভাগশেষ =1
3   / 2 = 1       ভাগশেষ =1
1   / 2 = 0       ভাগশেষ =1
{(248)ব্রেকেটের নিচে 10 } কে ডেসিমেল থেকে বাইনারি তে কনভাট করতে এখন আমাদের ভাগশেষ গুলোকে নিচ থেকে উপরে সাজাতে হবে (11111000)ব্রেকেটের নিচে 2 থাকবে 
*/


//{(248)ব্রেকেটের নিচে 10 }ডেসিমেল থেকে হেকজা-ডেসিমেল কনভাট -=//
const duo2 = 248;
console.log(duo2.toString(16)); 
/*
ডেসিমেল -- হেকজা-ডেসিমেল
248 / 16 = ১৫     ভাগশেষ =8
15  / 16 = 0      ভাগশেষ =15(F)
{(248)ব্রেকেটের নিচে 10 } কে ডেসিমেল থেকে হেকজা-ডেসিমেল তে কনভাট করতে এখন আমাদের ভাগশেষ গুলোকে নিচ থেকে উপরে সাজাতে হবে (F8)ব্রেকেটের নিচে 16 থাকবে 
*/

const g = 300;
const h = new Number(300);
console.log(g==h);
console.log(h===h);         //এখানে দেখেন যখন আমরা (g==h) দুইটা ইকুয়াল দিচ্ছি তখন মান আসতেছে true, এবং যখন আমরা (g===h) তিনটা ইকুয়াল দিচ্ছি তখন মান আসতেছে false, এর কারণ এখানে ডেটা টাইপ হিসেবে g = 300 নাম্বার এবং h = new Number(300) Object //
//Typeof করে দেখি//
console.log(typeof(g));
console.log(typeof(h));

const j = 1;
console.log(j.toPrecision(2));  //  toPrecision ব্যবহারের  কারণ যেখানে আমরা চাইবো যে এখানে সংখ্যা 2 এর বেশি থাকবে না, যেমন আমরা toPrecision(2) toPrecision পরে 2 ব্যবহার করেছি । ফলে j = 1 হয়েছে 1.0//

console.log(j.toPrecision(5));     //এখানে আবার  toPrecision(5) toPrecision পরে 5 ব্যবহার করার কারণে মান হয়েছে 1.0000

const k =685526555653;
console.log(k.toPrecision(5));      //আবার এখানে দেখেন k =685526555653 মান 5 সংখ্যা থেকে বেশি খাকার কারণে toPrecision পর 5 দেওয়ার কারণে  প্রথমে 5টি সংখ্যা বসিয়ে ইটুডি পাওয়ার(e+) বসিয়ে দিয়েছে  ফলে মান 6.8553e+11 হয়েছে // যার কারণে toPrecision ব্যবহার করা ভালো না (Note Recommend)//

const l = 597896566.258963;
console.log(l.toPrecision(4));
console.log(l.toFixed(4));     // toPrecision এবং toFixed এই দুইটার মধ্যে সব থেকে ভালো toFixed ব্যাবহার করা কারণ দুইটার মধ্যে ছেম মান েহবে না //

//Number meowth //
let newNum = Number.EPSILON;    //EPSILON মানে হচ্ছে (.)দশমিকের সর্বনিম্ন সংখ্যা থেকে 1 পর্যন্ত যে বিয়োগফল সে বিয়োগফলের হিসেব টা দেখাবে//
newNum = Number.MAX_VALUE ;      //JavaScript সাপোটেট সর্বচ্চ সংখ্যা MAX_VALUE//
console.log(newNum);
newNum = Number.MAX_SAFE_INTEGER;
console.log(newNum);
newNum = Number.MIN_VALUE;      //JavaScript সাপোটেট সর্বচ্চ সংখ্যা MIN_VALUE//
console.log(newNum);
newNum = Number.MIN_SAFE_INTEGER;
console.log(newNum);
newNum = Number.NEGATIVE_INFINITY;
console.log(newNum);
newNum = Number.POSITIVE_INFINITY;
console.log(newNum);
newNum = Number.NaN;
console.log(newNum);
